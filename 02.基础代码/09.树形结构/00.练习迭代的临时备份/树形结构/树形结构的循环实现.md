# 树形结构的循环实现

####  基本的树形结构

```vue
<script setup lang="ts">
import { ref, onMounted } from "vue"

interface TreeNode {
  id: number
  label: string
  children: TreeNode[] | undefined
  expanded: boolean
}

const treeData = ref<TreeNode[]>([
  {
    id: 1,
    label: "Node 1",
    children: [
      {
        id: 2,
        label: "Node 1-1",
        children: undefined,
        expanded: true,
      },
      {
        id: 3,
        label: "Node 1-2",
        children: [
          {
            id: 4,
            label: "Node 1-2-1",
            children: undefined,
            expanded: true,
          },
        ],
        expanded: true,
      },
    ],
    expanded: true,
  },
  {
    id: 5,
    label: "Node 2",
    children: undefined,
    expanded: false,
  },
])



const toggleNode = (node: TreeNode) => {
  // 点击这个节点时, 切换这个节点是否展开
  if (node.children && node.children.length > 0) {
    node.expanded = !node.expanded
    const queue: TreeNode[] = []
    node.children.forEach((item) => {
      queue.push(item)
    })
    while (queue.length > 0) {
      const child = queue.shift()
      if (child) {
        child.expanded = false
        if (child.children && child.children.length > 0) {
          child.children.forEach((item) => {
            queue.push(item)
          })
        }
      }
    }
  }
}

onMounted(() => {
  // 这是一个空队列
  const queue: TreeNode[] = []
  // 将数组推入队列
  treeData.value.forEach((item) => {
    queue.push(item)
  })
  // 队列长度 >0, 有数据了
  while (queue.length > 0) {
    // 数组的顶部移除数据, 先进先出, 返回的是第1个元素
    const node = queue.shift()
    if (node) {
      // 第1个元素存在, 设置一下不展开
      node.expanded = false
      // 如果有子节点, 
      if (node.children && node.children.length > 0) {
        // 就在这个节点的基础上, 把 子节点加入队列
        node.children.forEach((item) => {
          queue.push(item)
        })
      }
    }
  }
})

/**
 * 使用了 Vue 的模板语法来渲染树形菜单
 * 在 v-for 中遍历 treeData 数组中的每个节点, 并将节点的 label 属性渲染到页面上
 * 当节点被点击时，调用 toggleNode 方法来展开或折叠节点,并通过 v-if 判断节点是否展开
 */
</script>
<template>
  <div>
    <ul>
      <li v-for="node in treeData" :key="node.id">
        1. 当遍历树形结构的第1级时, 将数据渲染出来, 第1级总是会被展示出来
        <span @click="toggleNode(node)">{{ node.label }}</span>
        2. 接着判断是否展开?
        <ul v-if="node.expanded">
          3. 如果是展开, 循环树形结构的第2级, 
          <li v-for="child in node.children" :key="child.id">
            {{ child.label }}
          </li>
        </ul>
      </li>
    </ul>
  </div>
</template>

<style scoped></style>

```



#### vue3.2 + ts 树形菜单, 不要用递归, 用循环, 如何加层级?

下面是给循环加上层级.

```vue
<script setup lang="ts">
import { ref, onMounted } from "vue"

import { isNarrow, position as x } from "@/stores/states"

import { IMenu } from "../helpers/sideup-types"
import { sideupData } from "@/stores/data/sideup-data"
import { resolveUnref } from "@vueuse/shared"

// const isNarrow = ref(true)

const treeData = ref(sideupData)
/*
  const treeData = ref<IMenu[]>([
    {
      header: "Getting Started",
    },
    {
      href: "/test/test-xy-movable",
      title: "XY可移动",
      icon: "iconfont icon-xin",
    },
    {
      href: "/test/test-vue-dialog",
      title: "全向可移动缩放对话框",
      icon: "iconfont icon-xin",
    },
  ])
*/

const toggleNode = (node: IMenu) => {
  if (node.children && node.children.length > 0) {
    node.expanded = !node.expanded
    const queue: IMenu[] = []
    node.children.forEach((item) => {
      queue.push(item)
    })
    while (queue.length > 0) {
      const child = queue.shift()
      if (child) {
        child.expanded = false
        if (child.children && child.children.length > 0) {
          child.children.forEach((item) => {
            queue.push(item)
          })
        }
      }
    }
  }
}

onMounted(() => {
  const queue: IMenu[] = []
  const deep = 0 /* 给循环加上层级 */
  resolveUnref(treeData).forEach((item) => {
    queue.push(Object.assign(item, { deep }))
  })
  while (queue.length > 0) {
    const node = queue.shift()
    if (node) {
      node.expanded = false
      if (node.children && node.children.length > 0) {
        node.children.forEach((item) => {
          queue.push(Object.assign(item, { deep: deep + 1 }))
        })
      }
    }
  }
})

/**
 * 使用了 Vue 的模板语法来渲染树形菜单
 * 在 v-for 中遍历 treeData 数组中的每个节点, 并将节点的 label 属性渲染到页面上
 * 当节点被点击时，调用 toggleNode 方法来展开或折叠节点,并通过 v-if 判断节点是否展开
 * 第1个 ul 是父节点, 第2个ul, 在 li 下面 是子节点,
 */
</script>
<template>
  <div>
    <ul class="w-full bg-rose-500 group" :class="[isNarrow ? '' : 'static flex flex-col ']" :style="`width: ${x}px`">
      <li v-for="node in treeData" :key="node.id">
        <div @click="toggleNode(node)">
          <span v-if="node.header"> {{ node.header }} </span>
          <span v-if="node.icon" :class="['iconfont ', `${node.icon}`]"> </span>
          <component :is="node.href ? 'router-link' : 'span'" :to="node.href">
            {{ node.title }} --- {{ node.deep }}
          </component>
          <span v-if="node.children" />
        </div>

        <ul v-if="node.expanded">
          <li v-for="child in node.children" :key="child.id">
            <div :class="[isNarrow ? 'absolute  left-full ' : 'static w-full']">
              <span v-if="child.header"> {{ child.header }} </span>
              <span v-if="child.icon" :class="['iconfont ', `${child.icon}`]"> </span>
              <component :is="child.href ? 'router-link' : 'span'" :to="child.href">
                {{ child.title }} --- {{ child.deep }}
              </component>
              <span v-if="child.children" />
            </div>
          </li>
        </ul>
      </li>
    </ul>
  </div>
</template>

<style scoped></style>

```

vue3.2 + ts 树形菜单, 不要用递归, 用循环, 要能展开所有层级

```vue

<template>
  <ul>
    <li v-for="(item, index) in treeData" :key="index">
      <div @click="expand(item, index)">{{ item.name }}</div>
      <TreeItem v-if="item.children && item.open" :item="item" :treeData="item.children"></TreeItem>
    </li>
  </ul>
</template>

<script lang="ts">
import { defineComponent, ref } from 'vue'

interface TreeItem {
  open?: boolean;
  name: string;
  children?: any[];
}

export default defineComponent({
  props: {
    treeData: {
      type: Array as () => TreeItem[],
      required: true
    },
    item: {
      type: Object as () => TreeItem,
      required: true
    }
  },
  setup() {
    const expand = (item: TreeItem, index: number) => {
      // 首先将当前节点的open属性取反，使得该节点能够展开或者收缩
      item.open = !item.open
      if (item.children) {
        // 对当前节点的所有子节点递归调用expand函数
        for (let i = 0; i < item.children.length; i++) {
          expand(item.children[i], i);
        }
      }
    };
    return {
      expand
    }
  }
})
</script
```

```ts
// 使用广度优先遍历实现展开所有层级的树形菜单
let treeData = [
  {
    name: '一级菜单1',
    children: [
      {
        name: '二级菜单1',
        children: [
          {
            name: '三级菜单1'
          },
          {
            name: '三级菜单2'
          }
        ]
      },
      {
        name: '二级菜单2',
        children: [
          {
            name: '三级菜单3'
          },
          {
            name: '三级菜单4'
          }
        ]
      }
    ]
  },
  {
    name: '一级菜单2',
    children: [
      {
        name: '二级菜单3',
        children: [
          {
            name: '三级菜单5'
          },
          {
            name: '三级菜单6'
          }
        ]
      },
      {
        name: '二级菜单4',
        children: [
          {
            name: '三级菜单7'
          },
          {
            name: '三级菜单8'
          }
        ]
      }
    ]
  }
]

// 广度优先遍历函数
function traverseTree(treeData) {
  let queue = []; // 用于存放树中的节点，利用队列进行广度优先遍历
  let result = []; // 用于存放最后的结果

  // 将树的根节点放入队列中
  for (let i = 0; i < treeData.length; i++) {
    queue.push(treeData[i]);
  }

  // 当队列不为空时，循环遍历
  while (queue.length > 0) {
    // 从队列中取出一个节点
    let node = queue.shift();
    result.push(node);

    // 将该节点的子节点放入队列中
    if (node.children && node.children.length > 0) {
      for (let i = 0; i < node.children.length; i++) {
        queue.push(node.children[i]);
      }
    }
  }
  return result;
}

let result = traverseTree(treeData);
console.log(result);
```

