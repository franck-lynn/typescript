# nodejs 运行环境

nodejs 是基于 chrome v8 引擎的运行环境, v8 负责解释 js 代码, 主要是一些内置的 api. 调用这些 api 交给 v8引擎去执行

在node里做开发, 是后端的开发

node 无法调用 DOM 和 BOM操作, 因为这些是浏览器的环境, node里没有 DOM, BOM 运行环境

## nodejs 运行环境配置

```ts
server
|-- .esmrc
|-- server
|   |-- .eslintrc.cjs
|   |-- package.json
|-- |-- src
|   |   |-- 01.node的最简运行环境.md
|-- |-- |-- fs
|   |   |   |-- fs-readFile.ts      
|   |   |-- main.ts
|   |-- tsconfig.json
```

fs-readFile.ts 文件内容如下:

```ts
import path from "path"
import fs from "fs"
export const readFile = () => {
  console.log("有__dirname 变量---> ", __dirname)
  console.log("执行的路径---> ", process.cwd())
  fs.readFile(path.join(__dirname, "../01.node的最简运行环境.md"), { encoding: "utf-8" }, (err) => {
    if (err) console.log(err)
    else {
      console.log("成功读取到了数据")
    }
  })
}
```

main.ts 

```ts
import { readFile } from "./fs/fs-readFile"

readFile()
```

会产生一个临时缓存文件, 在 server 这个根目录下, 新建一个 .esmrc 文件, 可以抑制缓存文件的产生, 这个文件可以放在最外层 client, server 共同的根目录下也能起作用

```.esmrc
{
    "cache": false
}
```

在

#### 改为执行 server 根目录下的 main.ts

这是 右键 run code 是可以执行的

但是, 用 node -r esm src/main.ts 却不能执行, 原因是找不到模块, 可能是 node 执行参数的问题. 

在 package.json 文件中, 增加  "type": "module",

```json
{
  "name": "express-server",
  "version": "1.0.0",
  "description": "a simple image static server",
  "type": "module",
  "main": "main.ts",
  "scripts": {
    "server": "nodemon -x node --no-warnings --experimental-specifier-resolution=node --loader ts-node/esm src/main.ts --watch src",
    "server:esm-not-await": "nodemon -r esm -r tsconfig-paths/register src/main.ts --watch src",
    "top:await": "nodemon -x node --no-warnings --experimental-specifier-resolution=node --loader ts-node/esm src/main.ts --watch src",
    "server:commonjs": "nodemon -r esm src/main.ts --watch"
  },
  "author": "",
  "license": "ISC"
}

```

fs-readFile.ts 文件内容更改如下:

```ts
import path from "path"
import fs from "fs"
export const readFile = () => {
  // console.log("有__dirname 变量---> ", __dirname)
  console.log("执行的路径---> ", process.cwd())
  fs.readFile(path.join(process.cwd(), "./src/01.node的最简运行环境.md"), { encoding: "utf-8" }, (err) => {
    if (err) console.log(err)
    else {
      console.log("成功读取到了数据")
    }
  })
}
```

在 esm 模式下, __dirname 的变量并不存在, 所以, 要找到文件目录, 采用绝对路径和相对路径都可以找到文件, 但是, 相对路径是相对于

根目录 server 的

采用

```bash
 node run server
```

## 运行程序的好处是可以使用 顶层await 这些 新特性

例如, 可以把 fs-readFile.ts 文件内容更改如下:

```ts
import fs from "fs"

export const readFile = async () => {
  // console.log("有__dirname 变量---> ", __dirname)
  console.log("执行的路径---> ", process.cwd())
  // fs.readFile(path.join(process.cwd(), "./src/01.node的最简运行环境.md"), { encoding: "utf-8" }, (err) => {
  fs.readFile("./src/01.node的最简运行环境.md", { encoding: "utf-8" }, (err) => {
    if (err) console.log(err)
    else {
      console.log("成功读取到了数据")
    }
  })
}
```

main.ts 更改如下:

```ts
import { readFile } from "./fs/fs-readFile"
await readFile()
```

执行

```bash
 node run server
```

也是可以的

```bash
PS F:\working\study\typescript\typescript\01.基本配置\05.node最简环境\server> npm run server

> express-server@1.0.0 server
> nodemon -x node --no-warnings --experimental-specifier-resolution=node --loader ts-node/esm src/main.ts --watch src

[nodemon] 2.0.20
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): src\**\*
[nodemon] watching extensions: ts,json
[nodemon] starting `node --no-warnings --experimental-specifier-resolution=node --loader ts-node/esm src/main.ts`
执行的路径--->  F:\working\study\typescript\typescript\01.基本配置\05.node最简环境\server
成功读取到了数据
[nodemon] clean exit - waiting for changes before restart
```

## 如果在 server 上级目录执行程序呢? 

此时, process.cwd() 的执行路径会发生变化, 会提示找不到文件的路径, 所以, 对于路径还是处理一下的

```bash
执行的路径--->  F:\working\study\typescript\typescript\01.基本配置\05.node最简环境
```



## fs 文件系统

对文件的操作

