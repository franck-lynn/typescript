# http 基本web服务器

基本的web服务器就是采用原生的 http 模块

```ts
// 创建 web 服务器的实例
const server = http.createServer()
```

server 可以监听 request 请求,  根据路由的不同做出不同的响应

```ts
// 绑定 request 事件, 只要有客户端请求这个服务器, 就会触发
// request 事件, 从而触发这个事件处理函数
server.on("request", (req, res) => {
  const str = `请求的 URL 是 ${req.url}, 请求的类型是 ${req.method} `
  console.log("req===> ", str)
  res.setHeader("Content-type", "text/html; charset=utf-8")
  // 这里对 req.url 进行路由判断
  // 发送给客户端
  res.end(str)
})
```

调用服务器监听端口, 启动服务器

```ts
// 启动 http 服务器
server.listen(3000, () => {
  console.log("server is running at http://localhost:3000")
})
```

 http.createServer() 方法

会返回 服务器对象, 底层其实使用直接 new Server 对象

```ts
function createServer (opts, requestListener){
    return new Server(opts, requestListener)
}
```

当然, 也可以自己创建这个对象

```ts
const server = new http.Server((req, res) => {
    res.end('hello server')
})
server.listen(3000, () => {console.log("server is running at http://localhost:3000")})

```

从上面的分析可以看出, 创建 server 时, 会传入 一个回调函数, 这个函数会传入2个参数, req, res.

(https://zhuanlan.zhihu.com/p/60517110)[nodejs的http.createServer过程解析]

Server 的封装

```ts
function Server(requestListener) {
  if (!(this instanceof Server)) return new Server(requestListener);
  net.Server.call(this, { allowHalfOpen: true });
  // 收到http请求时执行的回调
  if (requestListener) {
    this.on('request', requestListener);
  }

  this.httpAllowHalfOpen = false;
  // 建立tcp连接的回调
  this.on('connection', connectionListener);

  this.timeout = 2 * 60 * 1000;
  this.keepAliveTimeout = 5000;
  this._pendingResponseData = 0;
  this.maxHeadersCount = null;
}
util.inherits(Server, net.Server);
```

发现_http_server.js也没有太多逻辑，继续看lib/net.js下的代码

```ts
function Server(options, connectionListener) {
  if (!(this instanceof Server))
    return new Server(options, connectionListener);

  EventEmitter.call(this);
  // connectionListener在http.js处理过了
  if (typeof options === 'function') {
    connectionListener = options;
    options = {};
    this.on('connection', connectionListener);
  } else if (options == null || typeof options === 'object') {
    options = options || {};

    if (typeof connectionListener === 'function') {
      this.on('connection', connectionListener);
    }
  } else {
    throw new errors.TypeError('ERR_INVALID_ARG_TYPE',
                               'options',
                               'Object',
                               options);
  }

  this._connections = 0;
  ......
  this[async_id_symbol] = -1;
  this._handle = null;
  this._usingWorkers = false;
  this._workers = [];
  this._unref = false;

  this.allowHalfOpen = options.allowHalfOpen || false;
  this.pauseOnConnect = !!options.pauseOnConnect;
}
```

至此http.createServer就执行结束了，我们发现这个过程还没有涉及到很多逻辑，并且还是停留到js层面。接下来我们继续分析listen函数的过程。该函数是net模块提供的。我们只看关键的代码。

```ts
Server.prototype.listen = function(...args) {
  // 处理入参，根据文档我们知道listen可以接收好几个参数，我们这里是只传了端口号9297
  var normalized = normalizeArgs(args);
  //  normalized = [{port: 9297}, null];
  var options = normalized[0];
  var cb = normalized[1];
  // 第一次listen的时候会创建，如果非空说明已经listen过
  if (this._handle) {
    throw new errors.Error('ERR_SERVER_ALREADY_LISTEN');
  }
  ......
  listenInCluster(this, null, options.port | 0, 4,
                      backlog, undefined, options.exclusive);
}
function listenInCluster() {
    ...
    server._listen2(address, port, addressType, backlog, fd);
}

_listen2 = setupListenHandle = function() {
    ......
    this._handle = createServerHandle(...);
    this._handle.listen(backlog || 511);
}
function createServerHandle() {
    handle = new TCP(TCPConstants.SERVER);
    handle.bind(address, port);
}
```

到这我们终于看到了tcp连接的内容，每一个服务器新建一个handle并且保存他，该handle是一个TCP对象。然后执行bind和listen函数。接下来我们就看一下TCP类的代码。TCP是C++提供的类。对于 c++, 这就需要进一步了解node 的源码了. 

#### request 对象

http.createServer(app)与app()的区别
